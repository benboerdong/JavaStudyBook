# Java基础



*[参考](https://snailclimb.gitee.io/javaguide/#/)*

## Java入门

### Java语言有哪些特点？

简单易学、面向对象（封装、继承、多态）、平台无关性、可靠性、安全性、支持多线程（C++语言本身不支持多线程，必须借助操作系统的多线程功能完成多线程的设计）、支持网络编、编译与解释共存

### Java三大特性： 封装、继承、多态

* #### **封装：**
  
  * 定义：隐藏类的属性及实现细节，不允许外部程序直接访问，只能通过该类提供的方法来实现对隐藏信息的操作与访问。
  * 目的：增强安全性，简化编程。使用者不必了解具体的实现细节，而只是通过外部接口和特定的访问权限来使用类的成员。
  * 实现：私有化类的属性，给每一个属性提供getter和setter方法。如果有有参构造，一定还要写一个无参构造方法。方便测试，加上toString方法。（可以使用引入lombok）
* ==封装可以使类具有独立性和隔离性；保证类的高内聚。只暴露给类外部或者子类必须的属性和操作。类封装的实现依赖类的修饰符（public、protected和private等）==
  
* #### **继承：（extends）**

  * 定义：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以使用父类的功能，但不能选择性继承。

  * 说明：继承是类与类之间的关系，是一种“ is a ”的关系。如：“狗”继承“动物”。此时的动物类就是父类或基类，狗类则是子类或派生类。

    * 注：Java中类之间只有单继承，一个类只有一个父类。（接口可以多继承）

  * 好处：子类拥有父类所有的属性和方法（除private修饰的属性与方法），从而实现代码的复用。

  * 特征：

    * 子类拥有父类非private的属性和方法

    * 子类可以拥有自己的属性和方法，即子类可以对父类扩展

    * 子类可以用自己的方式实现父类的方法

      [参考](https://blog.csdn.net/jianyuerensheng/article/details/51602015)
    
  * ==对现有类的一种复用机制。一个类如果继承现有的类，则这个类将拥有被继承类的所有非私有特性（属性和操作）。这里指的继承包含：类的继承和接口的实现。==

* #### 多态

  * 定义：对象的多种形态。
    
    * 具体说就是父类的引用指向子类对象。
    
  * 指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。
  
  * 当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。
  
  * ==多态是在继承的基础上实现的。多态的三个要素：继承、重写和父类引用指向子类对象。父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为，就是类多态特性。多态可以分成编译时多态和运行时多态。==
    * [多态经典实例](/docs/java/base/多态.md)
  

### JVM

#### JVM概念

Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。

**Java 程序从源代码到运行一般有下面 3 步：**

![过程](java%E5%9F%BA%E7%A1%80.assets/image-20201217132518657.png)



我们需要格外注意的是 .class->机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。

#### 为什么说Java语言是编译与解释共存？

高级编程语言按照程序的执行方式分为==编译型和解释型==两种。

​	`编译型语言`是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；

`解释型语言`是指解释器对源程序逐行解释成特定平台的机器码并立即执行。

Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译器（javac）编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。

### JDK与JRE的区别：

* #### JDK与JRE

   JDK是JavaJDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。

  **==JDK=JRE + javac + 工具==** 

  ​		JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。

  **==JRE=JVM+Java类库+Java命令+基础构件==**

* #### Java与C语言的区别

1. 都是面向对象的的语言，均支持封装、继承、多态
2. Java不提供指针访问直接访问内存，程序内存相对安全
3. Java单继承（接口支持多继承，类不支持），C语言支持多继承。
4. Java有自动的内存管理垃圾回收机制，不需要程序员手动释放无用的内存。

## Java语法

* ### java访问修饰符

| 修饰符    | 类内部 | 同个包（package） | 子类              | 其他范围 |
| --------- | ------ | ----------------- | ----------------- | -------- |
| public    | Y      | Y                 | Y                 | Y        |
| protected | Y      | Y                 | Y                 | N        |
| 无修饰符  | Y      | Y                 | N or Y(同一个包） | N        |
| private   | Y      | N                 | N                 | N        |

### Java基本类型

* 4类8种
  * 整型：byte-->short-->int-->long
  * 浮点型：float-->double
  * char类型：char
  * boolean类型：boolean(true/false)
  
  ==注：1B=8bit==

| 基本类型 | 位数 | 字节 | 默认值  | 引用数据类型 |
| -------- | ---- | ---- | ------- | ------------ |
| byte     | 8    | 1    | 0       | Byte         |
| short    | 16   | 2    | 0       | Short        |
| int      | 32   | 4    | 0       | Integer      |
| long     | 64   | 8    | 0L      | Long         |
| float    | 32   | 4    | 0f      | Float        |
| double   | 64   | 8    | 0d      | Double       |
| char     | 16   | 2    | 'u0000' | Character    |
| boolean  | 1    |      | false   | Boolean      |

![java基本数据类型](java%E5%9F%BA%E7%A1%80.assets/image-20201217133622838.png)

### 自增自减运算符（++   --）

自增自减，常见于算法题中用于对某一变量做自增1，或自减1的操作 ，是Java提供的一种特殊的运算符。

++和--运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。

> ==符号在前先加减，符号在后后加减。==

####  continue、break、和 return 的区别是什么？

在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：

1. `continue` ：指跳出当前的这一次循环，继续下一次循环。
2. `break` ：指跳出整个循环体，继续执行循环下面的语句。

`return` 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：

1. `return;` ：直接使用 return 结束方法执行，用于没有返回值函数的方法
2. `return value;` ：return 一个特定值，用于有返回值函数的方法

### java中泛型

Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。

### == 和 equals的区别：

* == ： 它的作用是判断两个对象的地址是否相等。即判断两个对象是否是同一个对象。（基本类型比较的值，引用数据类型比较的是内存地址值。）

* `equals（）`：是判断两个对象是否相等，不能用于比较基本类型的数据变量。`equals()`方法存在于Object类中。

  ```Java
  // Object类中代码
  public boolean equals(Object obj) {
       return (this == obj);
  }
  ```

  

  `equals()` 方法存在两种使用情况：

  - 情况 1：类没有覆盖 `equals()`方法。则通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象。使用的默认是 `Object`类`equals()`方法。
  - 情况 2：类覆盖了 `equals()`方法。一般，我们都覆盖 `equals()`方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。

#### `hashCode()`与`equalse()`

* 常见面试题：
  
* 你重写过 `hashcode` 和 `equals`么，为什么重写 `equals` 时必须重写 `hashCode` 方法？
  
* hashCode()：作用是获取哈希码，实际上返回的是一个int整数，此哈希码作用是确定对象在哈希表中的索引位置。hashCode()是Object的方法。

  * 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）

* 为什么重写 `equals` 时必须重写 `hashCode` 方法？

  ​	如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等，对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。**因此，equals 方法被覆盖过，则 `hashCode` 方法也必须被覆盖。**

  > `hashCode()`的默认行为是对堆上的对象产生独特值。如果没有重写 `hashCode()`，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）
  >
  > 
  >
  > java编程里有关约定：如果两个对象根据equals方法比较是相等的，那么调用这两个对象的任意一个hashcode方法都必须产生相同的结果。

* **为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？**

  因为 `hashCode()` 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 `hashCode`。

  我们刚刚也提到了 `HashSet`,如果 `HashSet` 在对比的时候，同样的 hashcode 有多个对象，它会使用 `equals()` 来判断是否真的相同。也就是说 `hashcode` 只是用来缩小查找成本。

* ### 重写（overwrite）与重载（overload）区别

  ####override（重写，覆盖）

  1. 方法名、参数、返回值相同
  2. 子类方法不能缩小父类方法的访问权限
  3. 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)
  4. 存在于父类和子类之间
  5. 方法被定义为final不能被重写

  #### overload（重载，过载）

  1. 参数类型、个数、顺序至少有一个不相同。
  2. 不能重载只有返回值不同的方法名。
  3. 存在于父类和子类、同类中。

  方法的重写(Overriding)和重载(Overloading)是Java多态性的不同表现。 重写(Overriding)是父类与子类之间多态性的一种表现，而重载(Overloading)是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被"屏蔽"了。